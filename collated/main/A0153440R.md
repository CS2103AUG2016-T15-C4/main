# A0153440R
###### \java\jym\manager\logic\commands\AddCommand.java
``` java
    public AddCommand(String description, Object ... objects) throws IllegalValueException{
    	if(objects.length > 3){//f**k in this case - this should never happen b/c we control parser. max args is date(s), location, priority
    		throw new IllegalArgumentException();
    	}
    	boolean isTask = true; //by default
    	for(Object o : objects){
    		if(o instanceof List){
    			List<LocalDateTime> d = (List<LocalDateTime>)o;
    			if(d.size() > 1)
    				isTask = false;
    			else
    				o = d.get(0);
    		}
    	}
//      final Set<Tag> tagSet = new HashSet<>();
//      for (String tagName : tags) {
//          tagSet.add(new Tag(tagName));
//      }
 //   	if(isTask){
        	this.toAdd = new Task(new Description(description), objects);
  //  	} else {
   // 		this.toAdd = new Event(new Description(description), objects);
 //   	}
    }
    public AddCommand(String description, Set<String> tags) throws IllegalValueException
    {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Task(
                new Description(description),
                new UniqueTagList(tagSet)
        );
    }
    public AddCommand(String description, LocalDateTime deadline, Set<String> tags) throws IllegalValueException
    {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Task(
                new Description(description),
                deadline,
                new UniqueTagList(tagSet)
        );
    }
    public AddCommand(String description, LocalDateTime deadline) throws IllegalValueException
    {
     
        this.toAdd = new Task(
                new Description(description),
                deadline
        );
    }
```
###### \java\jym\manager\logic\commands\EditCommand.java
``` java

public class EditCommand extends Command {
    public static final String COMMAND_WORD = "update";
    
    public static final String MESSAGE_UPDATE_TASK_SUCCESS = "Updated Task: %1$s";
    
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Updates the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer) DESCRIPTION [by DEADLINE]\n"
            + "Example: " + COMMAND_WORD + " 1 do this";
    
	private String newDescription;
	private Date newDeadline;
	private Date newStartDate;
	private Date newEndDate;
	private boolean clearDeadline;
	private boolean clearDuration;

	private final Task toUpdate;
	public final int targetIndex;
	
	public EditCommand(int index, String description, LocalDateTime newDeadline) throws IllegalValueException {
		this.targetIndex = index;
		this.newDescription = description;
		this.toUpdate = new Task(
				new Description(description),
				newDeadline,
				new UniqueTagList());
		}
	 public EditCommand(int index, String description, Object ... objects) throws IllegalValueException{
	    	if(objects.length > 3){//f**k in this case - this should never happen b/c we control parser.
	    		throw new IllegalArgumentException();
	    	}
	    	this.targetIndex = index;
	    	for(Object o : objects){
	    		if(o instanceof List){
	    			List<LocalDateTime> d = (List<LocalDateTime>)o;
	    			if(d.size() == 1)
	    				o = d.get(0);
	    		}
	    	}
//	      final Set<Tag> tagSet = new HashSet<>();
//	      for (String tagName : tags) {
//	          tagSet.add(new Tag(tagName));
//	      }
	   
	    	this.toUpdate = new Task(new Description(description), objects);
	    }

	@Override
	public CommandResult execute() {
		
		UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToUpdate = lastShownList.get(targetIndex - 1);

        try {
            model.updateTask(taskToUpdate, toUpdate);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }

        return new CommandResult(String.format(MESSAGE_UPDATE_TASK_SUCCESS, taskToUpdate));

	}

}
```
###### \java\jym\manager\logic\parser\Parser.java
``` java
    private List<LocalDateTime> getDates(DateGroup dg){
    	List<LocalDateTime> dates = new ArrayList<>();
    	if(dg.getDates().size() > 1){
    		dg.getDates().forEach(
    				d -> dates.add(LocalDateTime.ofInstant(d.toInstant(), 
    						ZoneId.systemDefault())));
    	} else {
    		dates.add(LocalDateTime.ofInstant(
    					dg.getDates().get(0).toInstant(), ZoneId.systemDefault()));
    	}
    	return dates;
    }
	/**
     * Parses arguments in the context of the add person command.
     *
     * @param args full command args string
     * @return the prepared command
     */
```
###### \java\jym\manager\logic\parser\Parser.java
``` java
    private Command prepareAdd(String args){
        final Matcher matcher = PERSON_DATA_ARGS_FORMAT.matcher(args.trim());
        matcher.matches();
        // Validate arg string format
//        if (!matcher.matches()) {
//            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
//        }
//        System.out.println(matcher.groupCount());
        
        com.joestelmach.natty.Parser p = new com.joestelmach.natty.Parser();
    	List<DateGroup> dg = p.parse(args);
        String[] sections; //split around the time
        
        
	    System.out.println("Section dates: ");
	    dg.forEach(n-> System.out.println(n.getText() + " " + n.getDates()));
	    System.out.println(LocalDateTime.now().toString());
        
        String priority = null;
        String date = null;
        String description = null;
        String location = null;
        LocalDateTime ldt = null;
        List<LocalDateTime> dates = null;
        
    	if(!dg.isEmpty() && dg.get(0) != null){
    		 dates = getDates(dg.get(0));

    		sections = args.split(dg.get(0).getText());
    		if(sections.length > 1){
            	location = sections[1];
            	description = sections[0];
            } else {
            	String[] furtherSects = sections[0].split("\\sat\\s");//for location
            	location = (furtherSects.length > 1)? furtherSects[1] : null;
            	description = furtherSects[0];
            }
    		
    		if(location != null && location.contains("at")){
        		location = location.substring(4);
        	}
        	if(description.endsWith("by ")){
        		description = description.split("\\sby\\s")[0];
        	}
    	} else {
    		sections = args.split("\\sat\\s");
    		description = sections[0];
    		if(sections.length > 1){
    			location = sections[1];
    		}
    	}
        if(args.contains("priority")){
        	String[] ps = args.split("\\spriority\\s");
        	priority = ps[1];
        }

        
//        
//        List<String> list = Arrays.asList(sections);
//        System.out.println("Section groups: ");
//        list.forEach(n-> System.out.println(n));
//        System.out.println(LocalDateTime.now().toString());
//        
        
        try {
            return new AddCommand(
                    description,
                    dates,
                    location
 //                   getTagsFromArgs(matcher.group("tagArguments"))
            );
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

```
###### \java\jym\manager\logic\parser\Parser.java
``` java
    private Command prepareComplete(String args) {
    	Optional<Integer> index = parseIndex(args);
    	if(!index.isPresent()){
    		return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, CompleteCommand.MESSAGE_USAGE));
    		
    	}
    	
    	return new CompleteCommand(index.get());
	}
```
###### \java\jym\manager\logic\parser\Parser.java
``` java
    private Command prepareEdit(String args){
    	final Matcher matcher = PERSON_DATA_ARGS_FORMAT_UPDATE.matcher(args.trim());
    	 if (!matcher.matches()) {
             return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
         }
    	 args = args.substring(args.indexOf(" ", 1));
    	 System.out.println(args);
         LocalDateTime ldt = null;
         com.joestelmach.natty.Parser p = new com.joestelmach.natty.Parser();
     	List<DateGroup> dg = p.parse(args);
         String[] sections; //split around the time
         
         String priority = null;
         String date = null;
         String description = null;
         String location = null;
         List<LocalDateTime> dates = null;
     	if(!dg.isEmpty() && dg.get(0) != null){
     		dates = getDates(dg.get(0));
     		
     		sections = args.split(dg.get(0).getText());
     		if(sections.length > 1){
             	location = sections[1];
             	description = sections[0];
             } else {
             	String[] furtherSects = sections[0].split("\\sat\\s");//for location
             	location = (furtherSects.length > 1)? furtherSects[1] : null;
             	description = furtherSects[0];
             }
     		
     		if(location != null && location.contains("at")){
         		location = location.substring(4);
         	}
         	if(description.endsWith("by ")){
         		description = description.split("\\sby\\s")[0];
         	}
     	} else {
     		sections = args.split("\\sat\\s");
     		description = sections[0];
     		if(sections.length > 1){
     			location = sections[1];
     		}
     	}
         if(args.contains("priority")){
         	String[] ps = args.split("\\spriority\\s");
         	priority = ps[1];
         }

         
         System.out.println("desc:" + description + " " + location + " " + ldt);
         
         
         Optional<Integer> index = parseIndex(matcher.group("index"));
         if(!index.isPresent()){
             return new IncorrectCommand(
                     String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
         }
         try {
             return new EditCommand(
                     index.get(),
                     description,
                     dates,
                     location
             );
         } catch (IllegalValueException ive) {
             return new IncorrectCommand(ive.getMessage());
         }
 
    	
    }
```
###### \java\jym\manager\model\task\Deadline.java
``` java
public class Deadline {

    public static final String MESSAGE_DEADLINE_CONSTRAINTS =
            "Task deadlines should be 2 alphanumeric/period strings separated by '@'";
    public static final String DEADLINE_VALIDATION_REGEX = "[\\w\\.]+@[\\w\\.]+";  // need to work on the deadline format

    private final String value;
    private LocalDateTime date;

    
    public Deadline(){
    	this.date = null;
    	this.value = "no deadline";
    }
    
    public Deadline(LocalDateTime dueDate){
    	assert dueDate != null;
    	this.date = dueDate;
    	value = dueDate.toString();
    	
    }
    
    /**
     * Validates given email.
     *
     * @throws IllegalValueException if given email address string is invalid.
     */
    public Deadline(String deadline) throws IllegalValueException {
        assert deadline != null;
        deadline = deadline.trim();
        if (!isValidDeadline(deadline)) {
            throw new IllegalValueException(MESSAGE_DEADLINE_CONSTRAINTS);
        }
        this.value = deadline;
        
    }
    public Deadline(Deadline other){
    	this.value = other.toString();
    	this.date = other.getDate();
    }
    /**
     * Returns if a given string is a valid person email.
     */
    public boolean isValidDeadline(String test) {
    	if(test == null) return false;
    	if(test.equals("no deadline")) return true;
    	
    	Parser p = new Parser();
    	List<DateGroup> dg = p.parse(test);
    	if(dg.isEmpty()) return false;
    	else {
    		this.date = LocalDateTime.ofInstant(dg.get(0).getDates().get(0).toInstant(), 
					ZoneId.systemDefault());
    		return true;
    	}
    	
	
    }

    @Override
    public String toString() {
    	if(this.date == null)
    		return value;
    	else
    		return this.date.format(DateTimeFormatter.ofPattern("dd-MMM-yyyy hh:mm a"));
    }
    
    public LocalDateTime getDate(){
    	return this.date;
    }
    
    public boolean hasDeadline(){
    	return this.date != null;
    }
    
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Deadline // instanceof handles nulls
                && this.value.equals(((Deadline) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

}
```
###### \java\jym\manager\model\task\Event.java
``` java
public class Event extends TaskManagerItem implements ReadOnlyTask {
	
	private Description descr;
	private Location loc;
	private Deadline startTime;
	private Deadline endTime;
	private double duration; //implementation gimmick - unnecessary to create another LDT because it should be fairly close to the eventDate. Therefore keep an int instead to make it more convenient.
	private Priority pri;
	
	public Event(Description description, Object ... objects) throws IllegalValueException{
		assert !CollectionUtil.isAnyNull(description, objects);
		this.descr = description;
		this.loc = new Location();
		this.startTime = new Deadline();
		this.pri = new Priority(0);
		for(int i = 0; i < objects.length; i++){
    		Object o = objects[i];
    		if(o instanceof String){
    			this.loc = new Location((String)o);
    		} else if(o instanceof Location){ 
    			this.loc = (Location)o;
    		} else if(o instanceof List){
    			List<LocalDateTime> l = (List<LocalDateTime>)o;
    			this.startTime = new Deadline(l.get(0));
    			this.endTime = new Deadline(l.get(1));
    		} else if(o instanceof Priority){
    			this.pri = (Priority)o;
    		} else if(o instanceof Integer){
    			this.pri = new Priority((Integer)o);
    		}
    	}
	}
	
	public Event(Description d, Location l, Deadline ldt, double dur, Priority p) {
		this.descr = d;
		this.loc = l;
		this.startTime = ldt;
		this.duration = dur;
		pri = p;
	}
	public Event(Description d, Deadline ldt, double dur){
		this.descr = d;
		this.loc = null;
		this.startTime = ldt;
		this.duration = dur;
	}
	
	@Override
	public Description getDescription() {
		return this.descr;
	}

	@Override
	public Location getLocation() {
		return this.loc;
	}

	@Override
	public Deadline getDate() {
		return this.startTime;
	}
	public LocalTime getStartTime(){
		return this.startTime.getDate().toLocalTime();
	}
	public Deadline getEndTime(){
		//this is bad form, fix when you can (when you're not strapped for time for a deadline two days away)
		long numHours = (long)duration;
		long numMins = (long) ((duration - (long)duration) * 60);
		long numSecs =  (long) (((duration - (long)duration) * 60) - (long)((duration - (long)duration) * 60));
		
		return endTime;//this.startTime.getDate().plusHours(numHours).plusMinutes(numMins).plusSeconds(numSecs).toLocalTime();
	}
	public String toString(){
		return getAsText();
	}

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(this.descr, this.loc, this.startTime);
    }
	@Override
	public Priority getPriority() {
		return this.pri;
	}
	@Override
	public UniqueTagList getTags() {
		// TODO Auto-generated method stub
		return null;
	}
	@Override
	public Complete getComplete() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String getDateString() {
		// TODO Auto-generated method stub
		return null;
	}
	
	

}
```
###### \java\jym\manager\model\task\Task.java
``` java
public class Task extends TaskManagerItem implements ReadOnlyTask {
	
	private Description descr;
	private Location loc;
	private Deadline dueDate; //doubles as start time for now.
	private Priority pri;
	private Complete compl;
	private Deadline endTime;
    private UniqueTagList tags;

    
	public Task(Description description, Object ... objects) throws IllegalValueException{
		assert !CollectionUtil.isAnyNull(description, objects);
		this.descr = description;
		this.loc = new Location();
		this.dueDate = new Deadline();
		this.endTime = null;
		this.pri = new Priority(0);
		for(int i = 0; i < objects.length; i++){
    		Object o = objects[i];
    		if(o instanceof String){
    			this.loc = new Location((String)o);
    		} else if(o instanceof Location){ 
    			this.loc = (Location)o;
    		} else if(o instanceof LocalDateTime){
    			this.dueDate = new Deadline((LocalDateTime)o);
    		} else if(o instanceof Deadline){ 
    			this.dueDate = (Deadline)o;
    		} else if(o instanceof List){
    			if(((List) o).size() == 1){
    				if(((List)o).get(0) instanceof LocalDateTime){
        				List<LocalDateTime> l = (List<LocalDateTime>)o;
    					this.dueDate = new Deadline(l.get(0));
    				} else {
    					this.dueDate = ((List<Deadline>) o).get(0);
    				}
    			} else {
    				if(((List) o).get(0) instanceof LocalDateTime){
        				List<LocalDateTime> l = (List<LocalDateTime>)o;
            			this.dueDate = new Deadline(l.get(0));
            			this.endTime = new Deadline(l.get(1));
        			} else {
        				//must be of type deadline
        				List<Deadline> l = (List<Deadline>)o;
        				this.dueDate = l.get(0);
        				this.endTime = l.get(1);
        			}
    			}
    		} else if(o instanceof Priority){
    			this.pri = (Priority)o;
    		} else if(o instanceof Integer){
    			this.pri = new Priority((Integer)o);
    		} else if(o instanceof UniqueTagList){
    			this.tags = new UniqueTagList((UniqueTagList)o);
    		}
    	}
	}
	public Task(Description d, Deadline due, Location location){
		this.descr = d;
		this.dueDate = due;
		this.loc = location;
	
	}
    /**
     * Every field must be present and not null.
     */

    public Task(Description description, Location location, Deadline due, Deadline end, Priority p, UniqueTagList tags) {
    //	assert !CollectionUtil.isAnyNull(description, location, due);
    	this.descr = description;
    	this.loc = (location == null)? new Location():location;
    	this.dueDate = (due == null) ? new Deadline():due;
    	this.endTime = (end == null) ? null : end;
    	this.pri = p;
        this.tags = new UniqueTagList(tags); // protect internal tags from changes in the arg list
    }
    /**
     * Copy constructor.
     * @throws IllegalValueException 
     */
    public Task(ReadOnlyTask source) {
        this(source.getDescription(), source.getLocation(), source.getDate(), source.getEndTime(), source.getPriority(), source.getTags());
    }
   
    public Task update(ReadOnlyTask source){
    	this.descr = source.getDescription();
    	if(source.getLocation() != null){
    		this.loc = source.getLocation();
    	}
    	if(source.getDate().hasDeadline()){
    		this.dueDate = source.getDate();
    	}
    	if(source.getEndTime() != null){
    		this.endTime = source.getEndTime();
    	}
    	
    	return this;
    }
    
    public Task(Description description, UniqueTagList tags) {
        assert !CollectionUtil.isAnyNull(description, tags);
        this.descr = description;
        this.tags = new UniqueTagList(tags); // protect internal tags from changes in the arg list
        this.loc = new Location();
        this.dueDate = new Deadline();
        this.pri = new Priority();
    }

    @Override
    public Description getDescription() {
        return this.descr;
    }

    @Override
    public Location getLocation() {
        return this.loc;
    }

	@Override
	public Deadline getDate() {
		return this.dueDate;
	}
	public Deadline getEndTime(){
		return this.endTime;
	}

	@Override
	public Priority getPriority() {
		return this.pri;
	}

    
    @Override
    public UniqueTagList getTags() {
        return new UniqueTagList(tags);
    }

    /**
     * Replaces this person's tags with the tags in the argument tag list.
     */
    public void setTags(UniqueTagList replacement) {
        tags.setTags(replacement);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyTask) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(this.descr, this.loc, tags);
    }

    @Override
    public String toString() {
        return getAsText();
    }

    public boolean hasDeadline(){
    	return this.dueDate != null && this.dueDate.hasDeadline();
    }
	@Override
	public Complete getComplete() {
		return this.compl;
	}
	public void setDescr(Description descr) {
		this.descr = descr;
	}
	public void setLoc(Location loc) {
		this.loc = loc;
	}
	public void setDueDate(Deadline dueDate) {
		this.dueDate = dueDate;
	}
	public void setPri(Priority pri) {
		this.pri = pri;
	}
	public void setCompl(Complete compl) {
		this.compl = compl;
	}
	public boolean isEvent(){
		return this.endTime != null;
	}
	public String getDateString(){
		if(this.endTime != null){
			return this.dueDate + " -> " + this.endTime; 
		}
		return this.dueDate.toString();
	}


}
```
###### \java\jym\manager\model\task\TaskManagerItem.java
``` java
public abstract class TaskManagerItem {

	
	
	public abstract Description getDescription();
	public abstract Location getLocation();
	public abstract Deadline getDate();

	
}
```
###### \java\jym\manager\model\TaskManager.java
``` java

    public void updateTask(ReadOnlyTask oldTask, Task updatedTask) throws UniqueTaskList.TaskNotFoundException {
    	tasks.update(oldTask, updatedTask);
    }

    public boolean completeTask(ReadOnlyTask key) throws UniqueTaskList.TaskNotFoundException {
    	if(tasks.remove(key)){
    		completedTasks.add(new Task(key));
    		completedTasks.forEach(t -> System.out.println("completed: " + t.getAsText()));
    		return true;
    	} else {
    		throw new UniqueTaskList.TaskNotFoundException();
    	}
    }
```
###### \java\jym\manager\storage\XmlAdaptedTask.java
``` java
    public Task toModelType() throws IllegalValueException {
        final List<Tag> personTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            personTags.add(tag.toModelType());
        }
        final Description desc = new Description(this.description);
        final Deadline dline = new Deadline(this.deadline);
        final Location addr = new Location(this.address);
        final UniqueTagList tags = new UniqueTagList(personTags);
        if(endTime != null){
        	final Deadline etime = new Deadline(this.endTime);
        	List<Deadline> l = new ArrayList();
        	l.add(dline);
        	l.add(etime);
        	return new Task(desc, l, addr, tags);
        }
        return new Task(desc, dline, addr, tags);
    }
}
```
###### \java\jym\manager\ui\TaskCard.java
``` java
    @FXML
    public void initialize() {
    	try{
	//    	System.out.println(task);
	        desc.setText(task.getDescription().toString());
	        id.setText(displayedIndex + ". ");
	        if(task.getLocation() != null) {
	        	address.setText(task.getLocation().toString());
	        }
	        if(task.getDate() != null) {
	        	deadline.setText("" + task.getDateString());
	        } else {
	        	deadline.setText("No deadline");
	        }
    	}catch(NullPointerException npe){
    		npe.printStackTrace();
    	}
 //       tags.setText(task.tagsString());
    }

    public HBox getLayout() {
        return cardPane;
    }

    @Override
    public void setNode(Node node) {
        cardPane = (HBox)node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}
```
